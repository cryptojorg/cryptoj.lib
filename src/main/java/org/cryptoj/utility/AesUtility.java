package org.cryptoj.utility;

import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.InvalidParameterSpecException;
import java.security.spec.KeySpec;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * Utility class to support AES based encryption and decryption.
 * Encryption and decryption is directly supported for strings.
 * Implementation is based on javax.crypto package.
 * In addition base64 encoding is supported for byte arrays.
 */
public class AesUtility {
	
	private static final byte [] SALT = new String("ldsqDQvEWJyWZMCl").getBytes();
	private static final int ITERATION_COUNT = 65536;
	private static final int KEY_STRENGTH = 256;
	
	private Cipher dcipher;
	private SecretKey key;
	private byte [] iv;
	
	/**
	 * Simple constructor for a provided pass phrase and 256 bit private key strength.
	 * The constructor also generates the private key that is used for encryption.
	 * @param passPhrase the pass phrase to encrypt data using {@link AesUtility.encrypt}
	 * @throws Exception
	 */
	public AesUtility(String passPhrase) throws Exception {
		this(passPhrase, SALT, ITERATION_COUNT, KEY_STRENGTH);
	}
	
	/**
	 * Detailed constructor.
	 * The constructor also generates the private key that is used for encryption.
	 * @param passPhrase the pass phrase to encrypt data using {@link AesUtility.encrypt}
	 * @param salt salt value to derive secret key
	 * @param iterationCount iteration count to derive secret key
	 * @param keyStrength desired secred key length in bits
	 */
	public AesUtility(String passPhrase, byte [] salt, int iterationCount, int keyStrength) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidParameterSpecException {
		SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
		KeySpec spec = new PBEKeySpec(passPhrase.toCharArray(), salt, iterationCount, keyStrength);
		SecretKey secret = factory.generateSecret(spec);
		key = new SecretKeySpec(secret.getEncoded(), "AES");
		dcipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
	}
	
	/**
	 * Returns the private key used for encryption.
	 */
	public SecretKey getSecretKey() {
		return key;
	}
	
	/**
	 * Returns the IV parameter that was generated by the most recent call of method {@link AESUtility.encrypt}.
	 * @return the IV parameter i base64 encoded format.
	 */
	public String getIv() {
		return bytesToBase64(iv);
	}

	/**
	 * Encrypt the provided string using the pass phrase provided in the AES utility constructor. 
	 * Before encryption of another value, you will need to record the IV parameter generated using method {@link AesUtility.getIv}.
	 * To decrypt the result this IV parameter will be needed again for method {@link AesUtility.decrypt}.
	 * @param data the input string
	 * @return the encrypted data in base64 encoded format
	 */
	public String encrypt(String data) throws Exception {
		dcipher.init(Cipher.ENCRYPT_MODE, key);
		iv = dcipher.getIV();
		byte[] utf8EncryptedData = dcipher.doFinal(data.getBytes());
		return bytesToBase64(utf8EncryptedData);
	}
	
	/**
	 * Decrypt the provided data using the provided IV parameter. 
	 * For more details see {@link AesUtility.encrypt}.
	 * @param base64encryptedData the data to decrypt
	 * @param base64encodedIv the IV parameter to be used for decryption
	 * @return the decrypted data encoded in base64 format
	 * @throws Exception
	 */
	public String decrypt(String base64encryptedData, String base64encodedIv) throws Exception {
		iv = base64ToBytes(base64encodedIv);
		dcipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
		byte[] decryptedData = base64ToBytes(base64encryptedData);
		byte[] utf8 = dcipher.doFinal(decryptedData);
		return new String(utf8, "UTF8");
	}

	/**
	 * Encodes the provided byte array to a base64 string.
	 * Implementation is based on class {@link Base64.Encoder}.
	 * @param bytes the byte array to be encoded
	 * @return the string encoding the provided byte array
	 */
	public static String bytesToBase64(byte [] bytes) {
		return Base64.getEncoder().encodeToString(bytes);
	}

	/**
	 * Decodes the base64 encoded string into a byte array.
	 * Implementation is based on class {@link Base64.Decoder}.
	 * @param base64EncodedData the string encoding a byte array
	 * @return the byte array corresponding to the input string
	 */
	public static byte [] base64ToBytes(String base64EncodedData) throws IOException {
		return Base64.getDecoder().decode(base64EncodedData);
	}			
	
}
